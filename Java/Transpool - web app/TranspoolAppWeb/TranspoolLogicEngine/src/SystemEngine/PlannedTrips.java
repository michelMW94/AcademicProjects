//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2020.05.31 at 05:01:16 PM IDT 
//


package SystemEngine;

import javax.xml.bind.annotation.*;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence maxOccurs="unbounded">
 *         &lt;element ref="{}TransPoolTrip"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "transPoolTrip"
})
@XmlRootElement(name = "PlannedTrips")
public class PlannedTrips {

    @XmlElement(name = "TransPoolTrip", required = true)
    protected List<TransPoolTrip> transPoolTrip;

    /**
     * Gets the value of the transPoolTrip property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the transPoolTrip property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTransPoolTrip().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TransPoolTrip }
     * 
     * 
     */
    public List<TransPoolTrip> getTransPoolTrip() {
        if (transPoolTrip == null) {
            transPoolTrip = new ArrayList<TransPoolTrip>();
        }
        return this.transPoolTrip;
    }

    public void SetOrderNumber ()
    {
        if (transPoolTrip != null) {
            transPoolTrip.forEach(transPoolTrip1 -> transPoolTrip1.setOrderNumber(transPoolTrip.indexOf(transPoolTrip1)));
        }
    }

    public void createRatingForEachTrip()
    {
        for(TransPoolTrip transPoolTrip1: this.getTransPoolTrip())
        {
            RatingDriver ratingDriver = new RatingDriver();
            transPoolTrip1.setRatingDriver(ratingDriver);
        }
    }
    public void SetCapacityList(List<Path> path)
    {
        if (transPoolTrip != null) {
            transPoolTrip.forEach(transPoolTrip1 -> transPoolTrip1.setCapacityPerTripList(createCapacityList(transPoolTrip1, path)));
        }
    }
    public List<CapacityPerTrip> createCapacityList(TransPoolTrip transPoolTrip, List<Path> path)
    {
        List<CapacityPerTrip> capacityPerTripList = new ArrayList<CapacityPerTrip>();
        int AddValue = (findAddValue(transPoolTrip.getScheduling().getRecurrences()));
        int firstDay = transPoolTrip.getScheduling().getDayStart();
        CapacityPerTrip capacityPerTrip =  createOneCapacityPerTRIP(transPoolTrip,path);
        for(int i = 1; i <= 365; i++ )
        {
            if(i == firstDay)
            {
                capacityPerTrip.setDayNumber(i);
                capacityPerTripList.add( new CapacityPerTrip(capacityPerTrip));
                firstDay = firstDay + AddValue;
            }
        }
        return capacityPerTripList;
    }
    private  int findAddValue(String recurrences)
    {
        int value = 0;
        switch (recurrences) {
            case "Daily":
                value = 1;
                break;
            case "BiDaily":
                value = 2;
                break;
            case "Weekly":
                value = 7;
                break;
            case "Monthly":
                value = 30;
                break;
        }
        return value;
    }
    private CapacityPerTrip createOneCapacityPerTRIP(TransPoolTrip transPoolTrip, List<Path> path)
    {
        CapacityPerTrip capacityPerTrip = new CapacityPerTrip();
        List<String> routesList = createRouteStopsStringsList(transPoolTrip.getRoute().getPath());
        String lastVisited = routesList.get(0);
        LocalTime localTime = LocalTime.of(transPoolTrip.getScheduling().getHourStart(),transPoolTrip.getScheduling().getMinuteStart());
        for(String station : routesList)
        {
            if(lastVisited.equals(station) == false)
            {
                int addMinutes = calculateTripDurationInMinutesCapacity(lastVisited + "," + station, path);
                localTime = localTime.plusMinutes(addMinutes);
            }
            OneCapacity oneCapacity = new OneCapacity();
            oneCapacity.setStationName(station);
            oneCapacity.setCapacityNum(transPoolTrip.getCapacity());
            oneCapacity.setOriginalCapacity(transPoolTrip.getCapacity());
            oneCapacity.setLocalTime(localTime);
            capacityPerTrip.AddToCapacityList(oneCapacity);
            lastVisited = station;
        }

        return  capacityPerTrip;
    }

    private int calculateTripDurationInMinutesCapacity(String route,List<Path> path ){
        int rideDurationMinutes = 0;
        List<String> routesList = createRouteStopsStringsList(route);

        for(int i = 0; i < routesList.size()-1; i++) {
            Path foundedPath = FindPathCapacity(routesList.get(i),routesList.get(i+1),path);
            rideDurationMinutes += (foundedPath.getLength() * 60)/foundedPath.getSpeedLimit();
        }

        return rideDurationMinutes;
    }


    public Path FindPathCapacity(String fromStation, String toStation,List<Path> path) {
        Optional<Path> FoundPath = path.stream()
                .filter(singlePath -> (singlePath.getFrom().equals(fromStation) && singlePath.getTo().equals(toStation))
                        || (singlePath.getFrom().equals(toStation) && singlePath.getTo().equals(fromStation) && singlePath.isOneWay() == false) )
                .findFirst();
        if(FoundPath.isPresent())
            return FoundPath.get();
        return null;
    }

    public  List<String> createRouteStopsStringsList (String stopStringsList) {
        return Arrays.asList(stopStringsList.trim().split(",")).stream()
                .map(w -> w.trim())
                .collect(Collectors.toList());
    }
    public void AddNewTranspoolTrip(TransPoolTrip Newtrip)
    {
        transPoolTrip.add(Newtrip);
    }

}
