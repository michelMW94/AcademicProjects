//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2020.04.16 at 03:58:25 PM IDT 
//


package Logic.SystemEngine;

import Logic.Exceptions.DuplicatedStopNameException;
import Logic.Exceptions.DuplicatedStopPointException;
import Logic.Exceptions.OutofBoundriesStopPointException;
import Logic.Exceptions.PathException;

import javax.xml.bind.annotation.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{}MapBoundries"/>
 *         &lt;element ref="{}Stops"/>
 *         &lt;element ref="{}Paths"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "mapBoundries",
    "stops",
    "paths"
})
@XmlRootElement(name = "MapDescriptor")
public class MapDescriptor {
    public static final int MINIMUME_CORDINATE_VALUE = 1;
    @XmlElement(name = "MapBoundries", required = true)
    protected MapBoundries mapBoundries;
    @XmlElement(name = "Stops", required = true)
    protected Stops stops;
    @XmlElement(name = "Paths", required = true)
    protected Paths paths;

    /**
     * Gets the value of the mapBoundries property.
     * 
     * @return
     *     possible object is
     *     {@link MapBoundries }
     *     
     */
    public MapBoundries getMapBoundries() {
        return mapBoundries;
    }

    /**
     * Sets the value of the mapBoundries property.
     * 
     * @param value
     *     allowed object is
     *     {@link MapBoundries }
     *     
     */
    public void setMapBoundries(MapBoundries value)  {
        this.mapBoundries = value;
    }

    /**
     * Gets the value of the stops property.
     * 
     * @return
     *     possible object is
     *     {@link Stops }
     *     
     */
    public Stops getStops() {
        return stops;
    }

    /**
     * Sets the value of the stops property.
     * 
     * @param value
     *     allowed object is
     *     {@link Stops }
     *     
     */
    public void setStops(Stops value) {
        this.stops = value;
    }

    /**
     * Gets the value of the paths property.
     * 
     * @return
     *     possible object is
     *     {@link Paths }
     *     
     */
    public Paths getPaths() {
        return paths;
    }

    /**
     * Sets the value of the paths property.
     * 
     * @param value
     *     allowed object is
     *     {@link Paths }
     *     
     */
    public void setPaths(Paths value) {
        this.paths = value;
    }

    public void checkPaths() throws Exception {
        for(Path singlePath : paths.getPath()) {
            if(stops.findStopByName(singlePath.from) == false || stops.findStopByName(singlePath.to) == false)
                throw new PathException(singlePath.from,singlePath.to, "doesn't exist in the System");
            else if (singlePath.from.equals(singlePath.to))
                throw new PathException(singlePath.from,singlePath.to, "has the same station names");
            else if(Collections.frequency(paths.path,singlePath) >1 )
                throw new PathException(singlePath.from,singlePath.to, "appears more than one time in the Paths");
        }
        /**modify stops of any extra space in the stop's name*/

    }
    public void checkStops () throws Exception {
        ArrayList<Point>  points = createPointsListFromStops();
        nameDuplicatesCheck();
        outOfMapBoundriesStopPointCheck();
        pointDuplicateCheck();
        /**modify stops of any extra space in the stop's name*/
        stops.stop.stream().forEach(stop -> stop.setName(stop.name.trim()));


    }

    private void nameDuplicatesCheck()  throws DuplicatedStopNameException {
        Optional<Stop> duplicatedStopByName = stops.stop.stream()
                .filter(i -> Collections.frequency(stops.stop, i) > 1).findFirst();
        if(duplicatedStopByName.isPresent())
            throw new DuplicatedStopNameException(duplicatedStopByName.get().name);

    }

    private void outOfMapBoundriesStopPointCheck() throws OutofBoundriesStopPointException {
        Optional<Stop> outOfBoundriesStop = stops.stop.stream().filter(s-> checkCordinates(s.x,s.y)).findFirst();
        if(outOfBoundriesStop.isPresent())
            throw new OutofBoundriesStopPointException(outOfBoundriesStop.get().x,outOfBoundriesStop.get().y,mapBoundries.width,mapBoundries.length);
    }
    private void pointDuplicateCheck() throws DuplicatedStopPointException {
        List<Point> pointList = stops.stop.stream().map(s-> new Point(s.x,s.y)).collect(Collectors.toList());
        Optional<Point> duplicatedPoint = pointList.stream().filter(p -> Collections.frequency(pointList,p) > 1).findFirst();
        if(duplicatedPoint.isPresent())
            throw new DuplicatedStopPointException(duplicatedPoint.get().x,duplicatedPoint.get().y);
    }

    public boolean checkCordinates(int x, int y) {
        if(x > mapBoundries.width || x < MINIMUME_CORDINATE_VALUE || y > mapBoundries.length || y < MINIMUME_CORDINATE_VALUE)
            return true;
        return false;
    }
    public ArrayList<Point> createPointsListFromStops() {
        ArrayList<Point> points = new ArrayList<Point>();
        for(Stop singleStop : stops.getStop()) {
            points.add(new Point(singleStop.x, singleStop.y));
        }
        return points;
    }

}
